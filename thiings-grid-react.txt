Directory Structure:

â””â”€â”€ ./
    â”œâ”€â”€ lib
    â”‚   â””â”€â”€ ThiingsGrid.tsx
    â”œâ”€â”€ src
    â”‚   â”œâ”€â”€ examples
    â”‚   â”‚   â”œâ”€â”€ CardLayout.tsx
    â”‚   â”‚   â”œâ”€â”€ ColorfulGrid.tsx
    â”‚   â”‚   â”œâ”€â”€ EmojiFun.tsx
    â”‚   â”‚   â”œâ”€â”€ SimpleNumbers.tsx
    â”‚   â”‚   â””â”€â”€ ThiingsIcons.tsx
    â”‚   â”œâ”€â”€ App.tsx
    â”‚   â”œâ”€â”€ index.css
    â”‚   â”œâ”€â”€ main.tsx
    â”‚   â”œâ”€â”€ Playground.tsx
    â”‚   â”œâ”€â”€ Sidebar.tsx
    â”‚   â”œâ”€â”€ SourceCode.tsx
    â”‚   â””â”€â”€ vite-env.d.ts
    â”œâ”€â”€ eslint.config.js
    â”œâ”€â”€ index.html
    â”œâ”€â”€ postcss.config.js
    â”œâ”€â”€ tailwind.config.js
    â””â”€â”€ vite.config.ts



---
File: /lib/ThiingsGrid.tsx
---

import React, { Component } from "react";

// Grid physics constants
const MIN_VELOCITY = 0.2;
const UPDATE_INTERVAL = 16;
const VELOCITY_HISTORY_SIZE = 5;
const FRICTION = 0.9;
const VELOCITY_THRESHOLD = 0.3;

// Custom debounce implementation
function debounce<T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number
) {
  let timeoutId: number | undefined = undefined;

  const debouncedFn = function (...args: Parameters<T>) {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      func(...args);
      timeoutId = undefined;
    }, wait);
  };

  debouncedFn.cancel = function () {
    clearTimeout(timeoutId);
    timeoutId = undefined;
  };

  return debouncedFn;
}

// Custom throttle implementation
function throttle<T extends (...args: unknown[]) => unknown>(
  func: T,
  limit: number,
  options: { leading?: boolean; trailing?: boolean } = {}
) {
  let lastCall = 0;
  let timeoutId: number | undefined = undefined;
  const { leading = true, trailing = true } = options;

  const throttledFn = function (...args: Parameters<T>) {
    const now = Date.now();

    if (!lastCall && !leading) {
      lastCall = now;
    }

    const remaining = limit - (now - lastCall);

    if (remaining <= 0 || remaining > limit) {
      clearTimeout(timeoutId);
      timeoutId = undefined;
      lastCall = now;
      func(...args);
    } else if (!timeoutId && trailing) {
      timeoutId = setTimeout(() => {
        lastCall = leading ? Date.now() : 0;
        timeoutId = undefined;
        func(...args);
      }, remaining);
    }
  };

  throttledFn.cancel = function () {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = undefined;
    }
  };

  return throttledFn;
}

function getDistance(p1: Position, p2: Position) {
  const dx = p2.x - p1.x;
  const dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

type Position = {
  x: number;
  y: number;
};

type GridItem = {
  position: Position;
  gridIndex: number;
};

type State = {
  offset: Position;
  isDragging: boolean;
  startPos: Position;
  restPos: Position;
  velocity: Position;
  gridItems: GridItem[];
  isMoving: boolean;
  lastMoveTime: number;
  velocityHistory: Position[];
};

export type ItemConfig = {
  isMoving: boolean;
  position: Position;
  gridIndex: number;
};

export type ThiingsGridProps = {
  gridSize: number;
  renderItem: (itemConfig: ItemConfig) => React.ReactNode;
  className?: string;
  initialPosition?: Position;
};

class ThiingsGrid extends Component<ThiingsGridProps, State> {
  private containerRef: React.RefObject<HTMLElement | null>;
  private lastPos: Position;
  private animationFrame: number | null;
  private isComponentMounted: boolean;
  private lastUpdateTime: number;
  private debouncedUpdateGridItems: ReturnType<typeof throttle>;

  constructor(props: ThiingsGridProps) {
    super(props);
    const offset = this.props.initialPosition || { x: 0, y: 0 };
    this.state = {
      offset: { ...offset },
      restPos: { ...offset },
      startPos: { ...offset },
      velocity: { x: 0, y: 0 },
      isDragging: false,
      gridItems: [],
      isMoving: false,
      lastMoveTime: 0,
      velocityHistory: [],
    };
    this.containerRef = React.createRef();
    this.lastPos = { x: 0, y: 0 };
    this.animationFrame = null;
    this.isComponentMounted = false;
    this.lastUpdateTime = 0;
    this.debouncedUpdateGridItems = throttle(
      this.updateGridItems,
      UPDATE_INTERVAL,
      {
        leading: true,
        trailing: true,
      }
    );
  }

  componentDidMount() {
    this.isComponentMounted = true;
    this.updateGridItems();

    // Add non-passive event listener
    if (this.containerRef.current) {
      this.containerRef.current.addEventListener("wheel", this.handleWheel, {
        passive: false,
      });
      this.containerRef.current.addEventListener(
        "touchmove",
        this.handleTouchMove,
        { passive: false }
      );
    }
  }

  componentWillUnmount() {
    this.isComponentMounted = false;
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }
    this.debouncedUpdateGridItems.cancel();

    // Remove event listeners
    if (this.containerRef.current) {
      this.containerRef.current.removeEventListener("wheel", this.handleWheel);
      this.containerRef.current.removeEventListener(
        "touchmove",
        this.handleTouchMove
      );
    }
  }

  public publicGetCurrentPosition = () => {
    return this.state.offset;
  };

  private calculateVisiblePositions = (): Position[] => {
    if (!this.containerRef.current) return [];

    const rect = this.containerRef.current.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;

    // Calculate grid cells needed to fill container
    const cellsX = Math.ceil(width / this.props.gridSize);
    const cellsY = Math.ceil(height / this.props.gridSize);

    // Calculate center position based on offset
    const centerX = -Math.round(this.state.offset.x / this.props.gridSize);
    const centerY = -Math.round(this.state.offset.y / this.props.gridSize);

    const positions: Position[] = [];
    const halfCellsX = Math.ceil(cellsX / 2);
    const halfCellsY = Math.ceil(cellsY / 2);

    for (let y = centerY - halfCellsY; y <= centerY + halfCellsY; y++) {
      for (let x = centerX - halfCellsX; x <= centerX + halfCellsX; x++) {
        positions.push({ x, y });
      }
    }

    return positions;
  };

  private getItemIndexForPosition = (x: number, y: number): number => {
    // Special case for center
    if (x === 0 && y === 0) return 0;

    // Determine which layer of the spiral we're in
    const layer = Math.max(Math.abs(x), Math.abs(y));

    // Calculate the size of all inner layers
    const innerLayersSize = Math.pow(2 * layer - 1, 2);

    // Calculate position within current layer
    let positionInLayer = 0;

    if (y === 0 && x === layer) {
      // Starting position (middle right)
      positionInLayer = 0;
    } else if (y < 0 && x === layer) {
      // Right side, bottom half
      positionInLayer = -y;
    } else if (y === -layer && x > -layer) {
      // Bottom side
      positionInLayer = layer + (layer - x);
    } else if (x === -layer && y < layer) {
      // Left side
      positionInLayer = 3 * layer + (layer + y);
    } else if (y === layer && x < layer) {
      // Top side
      positionInLayer = 5 * layer + (layer + x);
    } else {
      // Right side, top half (y > 0 && x === layer)
      positionInLayer = 7 * layer + (layer - y);
    }

    const index = innerLayersSize + positionInLayer;
    return index;
  };

  private debouncedStopMoving = debounce(() => {
    this.setState({ isMoving: false, restPos: { ...this.state.offset } });
  }, 200);

  private updateGridItems = () => {
    if (!this.isComponentMounted) return;

    const positions = this.calculateVisiblePositions();
    const newItems = positions.map((position) => {
      const gridIndex = this.getItemIndexForPosition(position.x, position.y);
      return {
        position,
        gridIndex,
      };
    });

    const distanceFromRest = getDistance(this.state.offset, this.state.restPos);

    this.setState({ gridItems: newItems, isMoving: distanceFromRest > 5 });

    this.debouncedStopMoving();
  };

  private animate = () => {
    if (!this.isComponentMounted) return;

    const currentTime = performance.now();
    const deltaTime = currentTime - this.lastUpdateTime;

    if (deltaTime >= UPDATE_INTERVAL) {
      const { velocity } = this.state;
      const speed = Math.sqrt(
        velocity.x * velocity.x + velocity.y * velocity.y
      );

      if (speed < MIN_VELOCITY) {
        this.setState({ velocity: { x: 0, y: 0 } });
        return;
      }

      // Apply non-linear deceleration based on speed
      let deceleration = FRICTION;
      if (speed < VELOCITY_THRESHOLD) {
        // Apply stronger deceleration at lower speeds for more natural stopping
        deceleration = FRICTION * (speed / VELOCITY_THRESHOLD);
      }

      this.setState(
        (prevState) => ({
          offset: {
            x: prevState.offset.x + prevState.velocity.x,
            y: prevState.offset.y + prevState.velocity.y,
          },
          velocity: {
            x: prevState.velocity.x * deceleration,
            y: prevState.velocity.y * deceleration,
          },
        }),
        this.debouncedUpdateGridItems
      );

      this.lastUpdateTime = currentTime;
    }

    this.animationFrame = requestAnimationFrame(this.animate);
  };

  private handleDown = (p: Position) => {
    if (this.animationFrame) {
      cancelAnimationFrame(this.animationFrame);
    }

    this.setState({
      isDragging: true,
      startPos: {
        x: p.x - this.state.offset.x,
        y: p.y - this.state.offset.y,
      },
      velocity: { x: 0, y: 0 },
    });

    this.lastPos = { x: p.x, y: p.y };
  };
  private handleMove = (p: Position) => {
    if (!this.state.isDragging) return;

    const currentTime = performance.now();
    const timeDelta = currentTime - this.state.lastMoveTime;

    // Calculate raw velocity based on position and time
    const rawVelocity = {
      x: (p.x - this.lastPos.x) / (timeDelta || 1),
      y: (p.y - this.lastPos.y) / (timeDelta || 1),
    };

    // Add to velocity history and maintain fixed size
    const velocityHistory = [...this.state.velocityHistory, rawVelocity];
    if (velocityHistory.length > VELOCITY_HISTORY_SIZE) {
      velocityHistory.shift();
    }

    // Calculate smoothed velocity using moving average
    const smoothedVelocity = velocityHistory.reduce(
      (acc, vel) => ({
        x: acc.x + vel.x / velocityHistory.length,
        y: acc.y + vel.y / velocityHistory.length,
      }),
      { x: 0, y: 0 }
    );

    this.setState(
      {
        velocity: smoothedVelocity,
        offset: {
          x: p.x - this.state.startPos.x,
          y: p.y - this.state.startPos.y,
        },
        lastMoveTime: currentTime,
        velocityHistory,
      },
      this.updateGridItems
    );

    this.lastPos = { x: p.x, y: p.y };
  };
  private handleUp = () => {
    this.setState({ isDragging: false });
    this.animationFrame = requestAnimationFrame(this.animate);
  };

  private handleMouseDown = (e: React.MouseEvent) => {
    this.handleDown({
      x: e.clientX,
      y: e.clientY,
    });
  };

  private handleMouseMove = (e: React.MouseEvent) => {
    e.preventDefault();
    this.handleMove({
      x: e.clientX,
      y: e.clientY,
    });
  };

  private handleMouseUp = () => {
    this.handleUp();
  };

  private handleTouchStart = (e: React.TouchEvent) => {
    const touch = e.touches[0];

    if (!touch) return;

    this.handleDown({
      x: touch.clientX,
      y: touch.clientY,
    });
  };

  private handleTouchMove = (e: TouchEvent) => {
    const touch = e.touches[0];

    if (!touch) return;

    e.preventDefault();
    this.handleMove({
      x: touch.clientX,
      y: touch.clientY,
    });
  };

  private handleTouchEnd = () => {
    this.handleUp();
  };

  private handleWheel = (e: WheelEvent) => {
    e.preventDefault();

    // Get the scroll deltas
    const deltaX = e.deltaX;
    const deltaY = e.deltaY;

    this.setState(
      (prevState) => ({
        offset: {
          x: prevState.offset.x - deltaX,
          y: prevState.offset.y - deltaY,
        },
        velocity: { x: 0, y: 0 }, // Reset velocity when scrolling
      }),
      this.debouncedUpdateGridItems
    );
  };

  render() {
    const { offset, isDragging, gridItems, isMoving } = this.state;
    const { gridSize, className } = this.props;

    // Get container dimensions
    const containerRect = this.containerRef.current?.getBoundingClientRect();
    const containerWidth = containerRect?.width || 0;
    const containerHeight = containerRect?.height || 0;

    return (
      <div
        ref={this.containerRef as React.RefObject<HTMLDivElement>}
        className={className}
        style={{
          position: "absolute",
          inset: 0,
          touchAction: "none",
          overflow: "hidden",
          cursor: isDragging ? "grabbing" : "grab",
        }}
        onMouseDown={this.handleMouseDown}
        onMouseMove={this.handleMouseMove}
        onMouseUp={this.handleMouseUp}
        onMouseLeave={this.handleMouseUp}
        onTouchStart={this.handleTouchStart}
        onTouchEnd={this.handleTouchEnd}
        onTouchCancel={this.handleTouchEnd}
      >
        <div
          style={{
            position: "absolute",
            inset: 0,
            transform: `translate3d(${offset.x}px, ${offset.y}px, 0)`,
            willChange: "transform",
          }}
        >
          {gridItems.map((item) => {
            const x = item.position.x * gridSize + containerWidth / 2;
            const y = item.position.y * gridSize + containerHeight / 2;

            return (
              <div
                key={`${item.position.x}-${item.position.y}`}
                style={{
                  position: "absolute",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  userSelect: "none",
                  width: gridSize,
                  height: gridSize,
                  transform: `translate3d(${x}px, ${y}px, 0)`,
                  marginLeft: `-${gridSize / 2}px`,
                  marginTop: `-${gridSize / 2}px`,
                  willChange: "transform",
                }}
              >
                {this.props.renderItem({
                  gridIndex: item.gridIndex,
                  position: item.position,
                  isMoving,
                })}
              </div>
            );
          })}
        </div>
      </div>
    );
  }
}

export default ThiingsGrid;



---
File: /src/examples/CardLayout.tsx
---

import ThiingsGrid, { type ItemConfig } from "../../lib/ThiingsGrid";

const CardCell = ({ gridIndex, position, isMoving }: ItemConfig) => (
  <div
    className={`absolute inset-1 flex flex-col items-center justify-center bg-white border border-gray-200 rounded-xl p-2 text-xs text-gray-800 transition-shadow ${
      isMoving ? "shadow-xl" : "shadow-md"
    }`}
  >
    <div className="text-base font-bold mb-1">#{gridIndex}</div>
    <div className="text-[10px] text-gray-500">
      {position.x}, {position.y}
    </div>
  </div>
);

export const CardLayout = () => (
  <ThiingsGrid
    gridSize={150}
    renderItem={CardCell}
  />
);

export default CardLayout;



---
File: /src/examples/ColorfulGrid.tsx
---

import ThiingsGrid, { type ItemConfig } from "../../lib/ThiingsGrid";

const ColorfulCell = ({ gridIndex }: ItemConfig) => {
  const colors = [
    "bg-red-300",
    "bg-green-300",
    "bg-blue-300",
    "bg-yellow-300",
    "bg-pink-300",
    "bg-cyan-300",
  ];
  const colorClass = colors[gridIndex % colors.length];

  return (
    <div
      className={`absolute inset-0 flex items-center justify-center ${colorClass} text-xs font-bold text-gray-800 shadow-sm`}
    >
      {gridIndex}
    </div>
  );
};

export const ColorfulGrid = () => (
  <ThiingsGrid gridSize={100} renderItem={ColorfulCell} />
);

export default ColorfulGrid;



---
File: /src/examples/EmojiFun.tsx
---

import ThiingsGrid, { type ItemConfig } from "../../lib/ThiingsGrid";

const EmojiCell = ({ gridIndex }: ItemConfig) => {
  const emojis = ["ðŸŽ¨", "ðŸš€", "ðŸŒŸ", "ðŸŽª", "ðŸŽ­", "ðŸŽ¨", "ðŸŽ¸", "ðŸŽ¯", "ðŸŽ²", "ðŸŽ³"];
  const emoji = emojis[gridIndex % emojis.length];

  return (
    <div className="absolute inset-2 flex items-center justify-center bg-gradient-to-br from-gray-100 to-white border border-gray-300 rounded-full text-2xl shadow-md">
      {emoji}
    </div>
  );
};

export const EmojiFun = () => (
  <ThiingsGrid
    gridSize={120}
    renderItem={EmojiCell}
    initialPosition={{ x: 0, y: 0 }}
  />
);

export default EmojiFun;



---
File: /src/examples/SimpleNumbers.tsx
---

import ThiingsGrid, { type ItemConfig } from "../../lib/ThiingsGrid";

const SimpleNumberCell = ({ gridIndex }: ItemConfig) => (
  <div className="absolute inset-1 flex items-center justify-center bg-blue-50 border border-blue-500 rounded text-sm font-bold text-blue-800">
    {gridIndex}
  </div>
);

export const SimpleNumbers = () => (
  <ThiingsGrid
    gridSize={80}
    renderItem={SimpleNumberCell}
    initialPosition={{ x: 0, y: 0 }}
  />
);

export default SimpleNumbers;



---
File: /src/examples/ThiingsIcons.tsx
---

import ThiingsGrid, { type ItemConfig } from "../../lib/ThiingsGrid";

const ThiingsIconCell = ({ gridIndex }: ItemConfig) => {
  const images = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
  return (
    <div className="absolute inset-1 flex items-center justify-center">
      <img
        draggable={false}
        src={`/thiings/${images[gridIndex % images.length]}.png`}
      />
    </div>
  );
};

export const ThiingsIcons = () => (
  <ThiingsGrid
    gridSize={160}
    renderItem={ThiingsIconCell}
    initialPosition={{ x: 0, y: 0 }}
  />
);

export default ThiingsIcons;



---
File: /src/App.tsx
---

import { useState } from "react";
import { Toaster } from "sonner";
import Sidebar from "./Sidebar";
import Playground from "./Playground";
import SourceCode from "./SourceCode";

function App() {
  const [currentExample, setCurrentExample] = useState(0);

  return (
    <div className="flex h-screen w-screen font-sans">
      <Sidebar
        currentExample={currentExample}
        onExampleChange={setCurrentExample}
      />
      <main className="flex flex-1 flex-col h-screen">
        <div className="flex-[3] relative bg-white border-b border-gray-200">
          <Playground currentExample={currentExample} />
        </div>
        <div className="flex flex-1 min-h-[300px]">
          <SourceCode currentExample={currentExample} />
        </div>
      </main>
      <Toaster position="top-right" richColors />
    </div>
  );
}

export default App;



---
File: /src/index.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  * {
    box-sizing: border-box;
  }

  html,
  body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  #root {
    width: 100%;
    height: 100%;
  }
}

@layer components {
  .range-slider {
    @apply w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer;
  }

  .range-slider::-webkit-slider-thumb {
    @apply appearance-none w-4 h-4 bg-blue-500 rounded-full cursor-pointer;
  }

  .range-slider::-moz-range-thumb {
    @apply w-4 h-4 bg-blue-500 rounded-full cursor-pointer border-0;
  }
}

/* Override default body styles that conflict with our layout */
body {
  margin: 0;
  padding: 0;
  min-width: 100vw;
  min-height: 100vh;
  display: block; /* Override the flex centering */
  place-items: unset; /* Remove centering */
}

#root {
  width: 100vw;
  height: 100vh;
  margin: 0;
  padding: 0;
}

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color: #213547;
  background-color: #ffffff;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #747bff;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #f9f9f9;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}



---
File: /src/main.tsx
---

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)



---
File: /src/Playground.tsx
---

import ThiingsIconsExample from "./examples/ThiingsIcons";
import SimpleNumbersExample from "./examples/SimpleNumbers";
import ColorfulGridExample from "./examples/ColorfulGrid";
import EmojiFunExample from "./examples/EmojiFun";
import CardLayoutExample from "./examples/CardLayout";

import thiingsIconsSource from "./examples/ThiingsIcons.tsx?raw";
import simpleNumbersSource from "./examples/SimpleNumbers.tsx?raw";
import colorfulGridSource from "./examples/ColorfulGrid.tsx?raw";
import emojiFunSource from "./examples/EmojiFun.tsx?raw";
import cardLayoutSource from "./examples/CardLayout.tsx?raw";

export const exampleComponents = [
  ThiingsIconsExample,
  SimpleNumbersExample,
  EmojiFunExample,
  ColorfulGridExample,
  CardLayoutExample,
];

export const sourceCodes = [
  thiingsIconsSource,
  simpleNumbersSource,
  emojiFunSource,
  colorfulGridSource,
  cardLayoutSource,
];

export const componentNames = sourceCodes.map((code) => {
  const match = code.match(/export\s+default\s+(\w+)/);
  return match?.[1] || "Unknown";
});
type PlaygroundProps = {
  currentExample: number;
};

const Playground = ({ currentExample }: PlaygroundProps) => {
  const ExampleComponent = exampleComponents[currentExample];

  return (
    <div className="flex-1 relative w-full h-full overscroll-none">
      <ExampleComponent />
    </div>
  );
};

export default Playground;



---
File: /src/Sidebar.tsx
---

import { componentNames } from "./Playground";

type SidebarProps = {
  currentExample: number;
  onExampleChange: (index: number) => void;
};

const Sidebar = ({ currentExample, onExampleChange }: SidebarProps) => (
  <aside className="flex-shrink-0 bg-gray-50 border-r border-gray-300 px-4 py-6 flex flex-col justify-between">
    <div>
      <div className="mb-8">
        <h2 className="mt-0 text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent tracking-tight">
          thiings-grid
        </h2>
        <div className="text-xs text-gray-500 font-medium tracking-wide uppercase">
          infinite scroll component
        </div>
      </div>

      <nav>
        <div className="list-none p-0 mb-8">
          {componentNames.map((exampleName, index) => (
            <div
              key={index}
              className={`mb-4 cursor-pointer px-3 py-2 rounded transition-colors ${
                currentExample === index
                  ? "bg-blue-50 border border-blue-500 font-bold"
                  : "hover:bg-gray-200"
              }`}
              onClick={() => onExampleChange(index)}
            >
              {exampleName}
            </div>
          ))}
        </div>
      </nav>
    </div>

    <div className="space-y-3">
      <a
        href="https://thiings.co"
        target="_blank"
        rel="noopener noreferrer"
        className="block w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg text-center text-sm transition-colors duration-200 no-underline"
      >
        explore thiings.co
      </a>

      <a
        href="https://github.com/charlieclark/thiings-grid"
        target="_blank"
        rel="noopener noreferrer"
        className="block w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg text-center text-sm transition-colors duration-200 no-underline"
      >
        view docs
      </a>
    </div>
  </aside>
);

export default Sidebar;



---
File: /src/SourceCode.tsx
---

import { componentNames, sourceCodes } from "./Playground";
import { toast } from "sonner";

import thingsGridSource from "../lib/ThiingsGrid.tsx?raw";

type SourceCodeProps = {
  currentExample: number;
};

const SourceCode = ({ currentExample }: SourceCodeProps) => {
  const currentComponentName = componentNames[currentExample];
  const currentSourceCode = sourceCodes[currentExample];

  const handleCopy = () => {
    navigator.clipboard.writeText(currentSourceCode).then(() => {
      toast.success("Example code copied to clipboard!");
    });
  };

  const handleCopyThiingsGrid = async () => {
    const thiingsGridCode = thingsGridSource;
    await navigator.clipboard.writeText(thiingsGridCode);
    toast.success("ThiingsGrid component copied to clipboard!");
  };

  return (
    <section className="flex-[2] p-4 border-r border-gray-200 bg-gray-50 flex flex-col">
      <div className="mb-4">
        <h3 className="m-0 text-lg font-semibold">{currentComponentName}</h3>
      </div>

      <pre className="bg-gray-100 p-4 rounded-lg text-xs leading-relaxed overflow-auto flex-1 border border-gray-200 font-mono mb-4">
        <code>{currentSourceCode}</code>
      </pre>

      <div className="flex gap-3">
        <button
          onClick={handleCopy}
          className="flex-1 px-4 py-2.5 bg-blue-600 text-white border-none rounded-lg cursor-pointer text-sm font-medium hover:bg-blue-700 transition-colors duration-200"
        >
          Copy Example
        </button>

        <button
          onClick={handleCopyThiingsGrid}
          className="flex-1 px-4 py-2.5 bg-gray-600 text-white border-none rounded-lg cursor-pointer text-sm font-medium hover:bg-gray-700 transition-colors duration-200"
        >
          Copy ThiingsGrid.tsx
        </button>
      </div>
    </section>
  );
};

export default SourceCode;



---
File: /src/vite-env.d.ts
---

/// <reference types="vite/client" />



---
File: /eslint.config.js
---

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)



---
File: /index.html
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ThiingsGrid | Infinite Scroll Component</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>



---
File: /postcss.config.js
---

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
} 


---
File: /tailwind.config.js
---

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
    "./lib/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
} 


---
File: /vite.config.ts
---

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  base: '/',
})

